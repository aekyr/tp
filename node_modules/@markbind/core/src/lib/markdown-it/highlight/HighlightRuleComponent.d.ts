export declare class HighlightRuleComponent {
    lineNumber: number;
    isSlice: boolean;
    bounds: Array<[number, number]>;
    constructor(lineNumber: number, isSlice?: boolean, bounds?: Array<[number, number]>);
    static isValidLineNumber(lineNumStr: string, min: number, max: number, offset: number): number | null;
    static parseRuleComponent(compString: string, lineNumberOffset: number, lines: string[]): HighlightRuleComponent | null;
    /**
     * Compares the component's line number to a given line number.
     *
     * @param lineNumber The line number to compare
     * @returns {number} A negative number, zero, or a positive number when the given line number
     *  is after, at, or before the component's line number
     */
    compareLine(lineNumber: number): number;
    isUnboundedSlice(): boolean;
    /**
     * Computes the actual character bound given a user-defined character bound and a line,
     * comparing the bounds and the line's range.
     *
     * If the bound does not specify either the start or the end bound, the computed bound will default
     * to the start or end of line. The bound can be either absolute or relative to the indentation level.
     *
     * @param bound The user-defined bound
     * @param line The given line
     * @param isAbsoluteIndexing Whether the bound is absolute or relative to the indentation level
     * @returns {[number, number]} The actual bound computed
     */
    static computeCharBounds(bound: [number, number], line: string, isAbsoluteIndexing: boolean): [number, number];
    /**
     * Computes the actual character bounds given a user-defined word bound and a line,
     * comparing the bounds and the line's range.
     *
     * If the bound does not specify either the start or the end bound, the computed bound will default
     * to the start or end of line, excluding leading whitespaces.
     *
     * @param bound The user-defined bound
     * @param line The given line
     * @returns {[number, number]} The actual bound computed
     */
    static computeWordBounds(bound: [number, number], line: string): [number, number];
    /**
     * Computes the actual bounds given a user-defined line part and a line.
     *
     * @param linePart The user-defined line part
     * @param line The given line
     * @returns {Array<[number, number]>} The bounds computed, each indicates the range of each
     * occurrences of the line part in the line
     */
    static computeLinePartBounds(linePart: string, line: string): Array<[number, number]>;
}
//# sourceMappingURL=HighlightRuleComponent.d.ts.map